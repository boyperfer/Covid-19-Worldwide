{"ast":null,"code":"\"use strict\";\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */\n\nvar wrappers = exports;\n\nvar Message = require(\"./message\");\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */\n\n/**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */\n\n/**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */\n// Custom wrapper for Any\n\n\nwrappers[\".google.protobuf.Any\"] = {\n  fromObject: function (object) {\n    // unwrap value type if mapped\n    if (object && object[\"@type\"]) {\n      var type = this.lookup(object[\"@type\"]);\n      /* istanbul ignore else */\n\n      if (type) {\n        // type_url does not accept leading \".\"\n        var type_url = object[\"@type\"].charAt(0) === \".\" ? object[\"@type\"].substr(1) : object[\"@type\"]; // type_url prefix is optional, but path seperator is required\n\n        return this.create({\n          type_url: \"/\" + type_url,\n          value: type.encode(type.fromObject(object)).finish()\n        });\n      }\n    }\n\n    return this.fromObject(object);\n  },\n  toObject: function (message, options) {\n    // decode value if requested and unmapped\n    if (options && options.json && message.type_url && message.value) {\n      // Only use fully qualified type name after the last '/'\n      var name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n      var type = this.lookup(name);\n      /* istanbul ignore else */\n\n      if (type) message = type.decode(message.value);\n    } // wrap value if unmapped\n\n\n    if (!(message instanceof this.ctor) && message instanceof Message) {\n      var object = message.$type.toObject(message, options);\n      object[\"@type\"] = message.$type.fullName;\n      return object;\n    }\n\n    return this.toObject(message, options);\n  }\n};","map":{"version":3,"sources":["/Users/vnfreedomboy/Desktop/map-react/client/node_modules/protobufjs/src/wrappers.js"],"names":["wrappers","exports","Message","require","fromObject","object","type","lookup","type_url","charAt","substr","create","value","encode","finish","toObject","message","options","json","name","substring","lastIndexOf","decode","ctor","$type","fullName"],"mappings":"AAAA;AAEA;;;;;;AAKA,IAAIA,QAAQ,GAAGC,OAAf;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,WAAD,CAArB;AAEA;;;;;;;;;AASA;;;;;;;;;;AAUA;;;;;;AAOA;;;AACAH,QAAQ,CAAC,sBAAD,CAAR,GAAmC;AAE/BI,EAAAA,UAAU,EAAE,UAASC,MAAT,EAAiB;AAEzB;AACA,QAAIA,MAAM,IAAIA,MAAM,CAAC,OAAD,CAApB,EAA+B;AAC3B,UAAIC,IAAI,GAAG,KAAKC,MAAL,CAAYF,MAAM,CAAC,OAAD,CAAlB,CAAX;AACA;;AACA,UAAIC,IAAJ,EAAU;AACN;AACA,YAAIE,QAAQ,GAAGH,MAAM,CAAC,OAAD,CAAN,CAAgBI,MAAhB,CAAuB,CAAvB,MAA8B,GAA9B,GACXJ,MAAM,CAAC,OAAD,CAAN,CAAgBK,MAAhB,CAAuB,CAAvB,CADW,GACiBL,MAAM,CAAC,OAAD,CADtC,CAFM,CAIN;;AACA,eAAO,KAAKM,MAAL,CAAY;AACfH,UAAAA,QAAQ,EAAE,MAAMA,QADD;AAEfI,UAAAA,KAAK,EAAEN,IAAI,CAACO,MAAL,CAAYP,IAAI,CAACF,UAAL,CAAgBC,MAAhB,CAAZ,EAAqCS,MAArC;AAFQ,SAAZ,CAAP;AAIH;AACJ;;AAED,WAAO,KAAKV,UAAL,CAAgBC,MAAhB,CAAP;AACH,GArB8B;AAuB/BU,EAAAA,QAAQ,EAAE,UAASC,OAAT,EAAkBC,OAAlB,EAA2B;AAEjC;AACA,QAAIA,OAAO,IAAIA,OAAO,CAACC,IAAnB,IAA2BF,OAAO,CAACR,QAAnC,IAA+CQ,OAAO,CAACJ,KAA3D,EAAkE;AAC9D;AACA,UAAIO,IAAI,GAAGH,OAAO,CAACR,QAAR,CAAiBY,SAAjB,CAA2BJ,OAAO,CAACR,QAAR,CAAiBa,WAAjB,CAA6B,GAA7B,IAAoC,CAA/D,CAAX;AACA,UAAIf,IAAI,GAAG,KAAKC,MAAL,CAAYY,IAAZ,CAAX;AACA;;AACA,UAAIb,IAAJ,EACIU,OAAO,GAAGV,IAAI,CAACgB,MAAL,CAAYN,OAAO,CAACJ,KAApB,CAAV;AACP,KAVgC,CAYjC;;;AACA,QAAI,EAAEI,OAAO,YAAY,KAAKO,IAA1B,KAAmCP,OAAO,YAAYd,OAA1D,EAAmE;AAC/D,UAAIG,MAAM,GAAGW,OAAO,CAACQ,KAAR,CAAcT,QAAd,CAAuBC,OAAvB,EAAgCC,OAAhC,CAAb;AACAZ,MAAAA,MAAM,CAAC,OAAD,CAAN,GAAkBW,OAAO,CAACQ,KAAR,CAAcC,QAAhC;AACA,aAAOpB,MAAP;AACH;;AAED,WAAO,KAAKU,QAAL,CAAcC,OAAd,EAAuBC,OAAvB,CAAP;AACH;AA3C8B,CAAnC","sourcesContent":["\"use strict\";\n\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */\nvar wrappers = exports;\n\nvar Message = require(\"./message\");\n\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */\n\n/**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */\n\n/**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */\n\n// Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n\n    fromObject: function(object) {\n\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n            var type = this.lookup(object[\"@type\"]);\n            /* istanbul ignore else */\n            if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ?\n                    object[\"@type\"].substr(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                return this.create({\n                    type_url: \"/\" + type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n\n        return this.fromObject(object);\n    },\n\n    toObject: function(message, options) {\n\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            var name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type)\n                message = type.decode(message.value);\n        }\n\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            object[\"@type\"] = message.$type.fullName;\n            return object;\n        }\n\n        return this.toObject(message, options);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}